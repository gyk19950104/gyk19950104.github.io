<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backends on gyk&#39;s blog</title>
    <link>https://gyk19950104.github.io/backend/</link>
    <description>Recent content in Backends on gyk&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 01 Jun 2021 17:40:00 +0800</lastBuildDate>
    
	<atom:link href="https://gyk19950104.github.io/backend/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>6.java杂项</title>
      <link>https://gyk19950104.github.io/backend/6.java%E6%9D%82%E9%A1%B9/</link>
      <pubDate>Tue, 01 Jun 2021 17:40:00 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/6.java%E6%9D%82%E9%A1%B9/</guid>
      <description>异常，包装类，注解，反射，枚举，泛型</description>
    </item>
    
    <item>
      <title>5。java集合框架</title>
      <link>https://gyk19950104.github.io/backend/5.java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 01 Jun 2021 17:39:34 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/5.java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4.java网络编程</title>
      <link>https://gyk19950104.github.io/backend/4.java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 01 Jun 2021 17:37:49 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/4.java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3.javaio流</title>
      <link>https://gyk19950104.github.io/backend/3.javaio%E6%B5%81/</link>
      <pubDate>Tue, 01 Jun 2021 17:37:33 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/3.javaio%E6%B5%81/</guid>
      <description>1.文件外 java将文件抽象为file类可以操作盘符上的文件
package wiki.mrx.www; import java.io.File; public class FileTest { public static void main(String[] args) { File f = new File(&amp;quot;/Users/gyk/desktop/test.txt&amp;quot;); System.out.println(f.canExecute() ); System.out.println(f.canRead()); System.out.println(f.getName()); System.out.println(f.canWrite()); System.out.println(f.exists()); System.out.println(f.getAbsoluteFile()); System.out.println(f.getAbsolutePath()); System.out.println(f.getParentFile()); System.out.println(f.getPath()); System.out.println(f.isDirectory()); System.out.println(f.isHidden()); System.out.println(f.lastModified()); System.out.println(f.length()); System.out.println(f.list()); } } 2.文件内 文件的本质是二进制的数据，可以把他们想像成水源和管道，他们都有进有出，根据传输的用途分为：
 处理文本文件的字符流 处理非文本文件的字节流 减少硬盘操作次数的处理流 转换流 数据流操作基本数据类型和string 对象流操作引用类型数据  =========================================== 处理文本文件的字符流
用FileReader和FileWriter完成文本文件复制,缓冲数组 ===========================================
//用FileReader和FileWriter完成文本文件复制 package wiki.mrx.www; import java.io.*; public class FileTest { public static void main(String[] args) throws IOException { //1.新建源文件和目标文件 File f1 = new File(&amp;quot;/Users/gyk/desktop/test.</description>
    </item>
    
    <item>
      <title>Java多线程</title>
      <link>https://gyk19950104.github.io/backend/2.java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 01 Jun 2021 17:22:28 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/2.java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1.多线程 多线程就是指多核CPU同时干多件事 在java中开启多线程有三种方法： 继承Thread类， 实现Runnable接口 实现Callable接口 但Thread因为是类的继承，所以有单继承的弊端， Runnable是接口实现，可以进行多继承， 使用时implements实现接口重写run方法，但无返回值， Callable是接口实现，可以进行多继承，也有返回值， 根据不同情况，合理选择使用Runnable和Callable接口 开启多线程后，由于多个线程执行顺序是由CPU自行调度， 这种不确定性会引起执行结果的不稳定性，除执行顺序外， 还可能出现多个线程同时操作同一份资源的情况，这会导 致资源不安全，所以需要线程同步，它的本质是一种等待 的机制，在JDK5之前，我们可以通过synchronized方 法或者synchronized同步块来对资源进行隐式加锁，保 证安全，在JDK5之后，我们可以通过lock锁机制来显式加 锁，保证安全，一般少量代码用synchronized，大量代码 用lock锁 👉synchronized方法： 可以通过private关键字来保证数据对象只能被方法访问， 所以只需要对这个方法提出一套机制，这套机制就是 synchronized 关键字，即synchronized方法 👉synchronized同步块： 有时并不需要对数据添加private关键字 ，而是在代码 中直接使用synchronized( Obj ){ }同步块，obj是 类似于上面的私有数据对象 👉lock锁机制： 多线程编程时同步队列会出现很多常见涉及到锁的情形， 在java中将这些多线程常见情形抽象封装成开箱即用的 工具包，叫做JUC，常见的JUC.locks，JUC.automic 等，它包含了很多接口和实现类，可以拿来即用 =========================================== 2.1创建：thread，runnable，callable ===========================================
//创建 //继承Thread类,重写run方法，新建对象后start开启线程 package wiki.mrx.www; public class TestThread extends Thread{ //主线程 public static void main(String[] args) { //创建并开启线程 TestThread t1 = new TestThread(); t1.start(); //主线程代码 for (int i=0;i&amp;lt;20;i++){ System.out.println(&amp;quot;我在学习多线程&amp;quot;+i); } } @Override public void run() { for (int i=0;i&amp;lt;20;i++){ System.</description>
    </item>
    
    <item>
      <title>java面向对象</title>
      <link>https://gyk19950104.github.io/backend/1.java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Tue, 01 Jun 2021 17:22:15 +0800</pubDate>
      
      <guid>https://gyk19950104.github.io/backend/1.java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>先有逻辑正确的思路，剩余的是重复的实践与积累
1.面向对象 ===========================================
1.1 类是有属性，方法和构造器的模版，对象是实例
===========================================
1.2 面向对象的三大特性：
===========================================
 封装：修饰符，get,set方法 继承：extends，super，源头object 多态：同一行为，不同子类有不同表现，继承，子类重写父类方法，父类引用指向子类实例  //父类 package wiki.mrx.www; public class Person { //属性 private String name; static int age; //构造器：用于初始化数据 public Person(String name, int age) { this.name = name; this.age = age; } //get方法 public String getName() { return name; } public static int getAge() { return age; } //set方法 public void setName(String name) { this.name = name; } public static void setAge(int age) { Person.</description>
    </item>
    
  </channel>
</rss>